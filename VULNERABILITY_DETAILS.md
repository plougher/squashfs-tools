# Detailed Vulnerability Analysis

This document provides detailed technical analysis of each identified vulnerability class with specific code examples and exploitation scenarios.

## 1. Buffer Overflow Vulnerabilities

### CVE-Style Analysis: Unsafe String Concatenation

#### Vulnerability 1: Nested strcat() without runtime validation

**File:** `squashfs-tools/mksquashfs.c`  
**Lines:** 3195-3214  
**Function:** `getbase()`  
**Severity:** HIGH

**Vulnerable Code:**
```c
while(1) {
    if(*pathname != '/') {
        result = getcwd(b_buffer, b_size);
        if(result == NULL && errno != ERANGE)
            BAD_ERROR("Getcwd failed in getbase\n");

        /* enough room for pathname + "/" + '\0' terminator? */
        if(result && strlen(pathname) + 2 <= b_size - strlen(b_buffer)) {
            strcat(strcat(b_buffer, "/"), pathname);  // VULNERABLE
            break;
        }
    } else if(strlen(pathname) < b_size) {
        strcpy(b_buffer, pathname);  // VULNERABLE
        break;
    }

    /* Buffer not large enough, realloc and try again */
    b_buffer = REALLOC(b_buffer, b_size += BUFF_SIZE);
}
```

**Vulnerability Details:**

1. **TOCTOU Issue:** Between the bounds check (line 3202) and the string operation (line 3204), `b_buffer` could theoretically be modified by another thread
2. **Complex Expression:** Nested `strcat()` makes the code hard to audit and reason about
3. **Integer Overflow:** If `strlen(b_buffer)` is near `SIZE_MAX`, subtraction could underflow

**Attack Scenario:**

If an attacker can control:
- `pathname` content (e.g., through command line arguments or file names)
- Timing (in multi-threaded scenarios)

Then they could:
1. Provide a pathname that passes the initial check
2. Cause buffer content to change before strcat
3. Overflow the buffer with controlled data

**Proof of Concept:**
```c
// Malicious pathname just under the limit
char evil_path[BUFF_SIZE - 10];
memset(evil_path, 'A', sizeof(evil_path) - 1);
evil_path[sizeof(evil_path) - 1] = '\0';

// If getcwd returns more data than expected
// or if calculation is off by one, overflow occurs
```

**Fix:**
```c
// Safe version
if(*pathname != '/') {
    result = getcwd(b_buffer, b_size);
    if(result == NULL && errno != ERANGE)
        BAD_ERROR("Getcwd failed in getbase\n");

    size_t current_len = strlen(b_buffer);
    size_t pathname_len = strlen(pathname);
    size_t needed = current_len + pathname_len + 2; // "/" + pathname + '\0'
    
    if(result && needed <= b_size) {
        // Use safer operations
        snprintf(b_buffer + current_len, b_size - current_len, "/%s", pathname);
        break;
    }
}
```

#### Vulnerability 2: Multiple strcat() in loop

**File:** `squashfs-tools/unsquashfs.c`  
**Lines:** 1840-1862  
**Function:** `create_pathname()`  
**Severity:** HIGH

**Vulnerable Code:**
```c
int i, size = 0;
char *pathname;

/* work out how much space is needed for the pathname */
for(i = 1; i < stack->size; i++)
    size += strlen(stack->stack[i].name);

/* add room for leaf name, slashes and '\0' terminator */
size += strlen(name) + stack->size;

pathname = MALLOC(size);
pathname[0] = '\0';

/* concatenate */
for(i = 1; i < stack->size; i++) {
    strcat(pathname, stack->stack[i].name);  // VULNERABLE
    strcat(pathname, "/");                   // VULNERABLE
}

strcat(pathname, name);  // VULNERABLE
```

**Vulnerability Details:**

1. **Integer Overflow in Size Calculation:** If `stack->size` is very large and names are long:
   ```c
   // Example: 10000 entries * 1000 chars = 10,000,000
   // But INT_MAX is 2,147,483,647
   // If this overflows, size wraps around to small value
   size += strlen(stack->stack[i].name);
   ```

2. **No Runtime Verification:** After calculating size, no check that concatenation stays within bounds

3. **Assumption of Correct Calculation:** If size calculation has off-by-one error, buffer overflow

**Attack Scenario:**

1. Create deeply nested directory structure (large `stack->size`)
2. Use long directory names
3. Cause integer overflow in size calculation
4. `MALLOC(size)` allocates small buffer
5. `strcat()` operations overflow the buffer

**Proof of Concept:**
```c
// Assume 32-bit int
// Create directory structure that causes overflow
int stack_size = 50000;
char *names[50000];
for(int i = 0; i < 50000; i++) {
    names[i] = malloc(50000);  // 50KB each
    memset(names[i], 'A', 49999);
    names[i][49999] = '\0';
}

// size calculation:
// size = 50000 * 50000 = 2,500,000,000 (fits in int)
// size += 50000 = 2,500,050,000 > INT_MAX (2,147,483,647)
// Overflow! size becomes negative or wraps to small positive
```

**Fix:**
```c
int i;
size_t size = 0;  // Use size_t, not int
char *pathname;

/* work out how much space is needed */
for(i = 1; i < stack->size; i++) {
    size_t name_len = strlen(stack->stack[i].name);
    // Check for overflow
    if(SIZE_MAX - size < name_len)
        BAD_ERROR("Pathname too long\n");
    size += name_len;
}

size_t name_len = strlen(name);
if(SIZE_MAX - size < name_len + stack->size)
    BAD_ERROR("Pathname too long\n");
    
size += name_len + stack->size;

pathname = MALLOC(size);

/* Use safer concatenation with bounds tracking */
size_t offset = 0;
for(i = 1; i < stack->size; i++) {
    int written = snprintf(pathname + offset, size - offset, 
                          "%s/", stack->stack[i].name);
    if(written < 0 || (size_t)written >= size - offset)
        BAD_ERROR("Pathname buffer overflow\n");
    offset += written;
}

int written = snprintf(pathname + offset, size - offset, "%s", name);
if(written < 0 || (size_t)written >= size - offset)
    BAD_ERROR("Pathname buffer overflow\n");
```

## 2. Integer Overflow Vulnerabilities

### Analysis: Size Calculation Overflows

#### Vulnerability 3: Unchecked arithmetic before allocation

**File:** `squashfs-tools/mksquashfs.c`  
**Lines:** 4665-4672  
**Function:** Not specified  
**Severity:** MEDIUM

**Vulnerable Code:**
```c
char *orig = *pathname;
int size = strlen(orig) + (source - path) + 2;  // VULNERABLE

*pathname = MALLOC(size);
strcpy(*pathname, orig);
strcat(*pathname, "/");
strncat(*pathname, path, source - path);
```

**Vulnerability Details:**

1. **Integer Overflow:** `strlen(orig) + (source - path) + 2` could overflow
2. **Pointer Arithmetic:** `(source - path)` could be negative if pointers are invalid
3. **Small Allocation:** If overflow occurs, `MALLOC(size)` allocates small buffer
4. **Buffer Overflow:** `strcpy()` and `strcat()` then overflow

**Attack Scenario:**

```c
// If orig is very long string (close to INT_MAX)
char *orig = malloc(INT_MAX - 100);
memset(orig, 'A', INT_MAX - 101);
orig[INT_MAX - 101] = '\0';

// And (source - path) is large
ptrdiff_t diff = 200;

// Then: strlen(orig) + diff + 2 = (INT_MAX - 100) + 200 + 2 
//     = INT_MAX + 102 (OVERFLOW!)
//     = Wraps to 102

// MALLOC(102) allocates tiny buffer
// strcpy(pathname, orig) writes INT_MAX-100 bytes
// HEAP OVERFLOW!
```

**Fix:**
```c
char *orig = *pathname;
size_t orig_len = strlen(orig);
ptrdiff_t diff = source - path;

// Validate pointer difference
if(diff < 0 || diff > INT_MAX)
    BAD_ERROR("Invalid path difference\n");

// Check for overflow
size_t size;
if(__builtin_add_overflow(orig_len, (size_t)diff, &size) ||
   __builtin_add_overflow(size, 2, &size))
    BAD_ERROR("Path size overflow\n");

*pathname = MALLOC(size);
// Use snprintf for safety
snprintf(*pathname, size, "%s/%.*s", orig, (int)diff, path);
```

#### Vulnerability 4: Shift-based size calculation

**File:** `squashfs-tools/mksquashfs.c`  
**Lines:** 682-689  
**Function:** Not specified  
**Severity:** LOW-MEDIUM

**Vulnerable Code:**
```c
int realloc_size = cache_size == 0 ?
    ((req_size + SQUASHFS_METADATA_SIZE) &
    ~(SQUASHFS_METADATA_SIZE - 1)) : req_size - cache_size;
    
data_cache = REALLOC(data_cache, cache_size + realloc_size);
cache_size += realloc_size;
```

**Vulnerability Details:**

1. **Assumption:** Code assumes `SQUASHFS_METADATA_SIZE` is power of 2
2. **Unchecked Addition:** `cache_size + realloc_size` not checked for overflow
3. **Bit Manipulation:** Complex bit operations hard to audit

**Attack Scenario:**

If `SQUASHFS_METADATA_SIZE` is not a power of 2 (e.g., due to #define change):
```c
// Assume someone changes:
// #define SQUASHFS_METADATA_SIZE 8192
// to:
// #define SQUASHFS_METADATA_SIZE 8000

// Then ~(SQUASHFS_METADATA_SIZE - 1) is not a valid mask
// Result is unpredictable size calculation
```

If `cache_size` is near `INT_MAX`:
```c
int cache_size = INT_MAX - 100;
int realloc_size = 200;
// cache_size + realloc_size = INT_MAX + 100 (OVERFLOW)
// Wraps to small negative or small positive
// REALLOC with wrong size
```

**Fix:**
```c
// Add static assertion for power of 2
_Static_assert((SQUASHFS_METADATA_SIZE & (SQUASHFS_METADATA_SIZE - 1)) == 0,
               "SQUASHFS_METADATA_SIZE must be power of 2");

int realloc_size = cache_size == 0 ?
    ((req_size + SQUASHFS_METADATA_SIZE) &
    ~(SQUASHFS_METADATA_SIZE - 1)) : req_size - cache_size;

// Check for overflow before addition
if(add_overflow(cache_size, realloc_size))
    BAD_ERROR("Cache size overflow\n");
    
data_cache = REALLOC(data_cache, cache_size + realloc_size);
cache_size += realloc_size;
```

## 3. Memory Safety Issues

### Analysis: Memory Management Patterns

#### Vulnerability 5: Recursive free with potential stack overflow

**File:** `squashfs-tools/mksquashfs.c`  
**Lines:** 4246-4264  
**Function:** `free_dir()`  
**Severity:** LOW-MEDIUM

**Vulnerable Code:**
```c
void free_dir(struct dir_info *dir)
{
    struct dir_ent *dir_ent = dir->list;
    
    while(dir_ent) {
        struct dir_ent *tmp = dir_ent;
        
        if((dir_ent->inode->buf.st_mode & S_IFMT) == S_IFDIR)
            if(dir_ent->dir)
                free_dir(dir_ent->dir);  // RECURSIVE CALL
        
        dir_ent = dir_ent->next;
        free_dir_entry(tmp);
    }
    
    free(dir->pathname);
    free(dir->subpath);
    free(dir);
}
```

**Vulnerability Details:**

1. **Unbounded Recursion:** No depth limit on recursive calls
2. **Stack Overflow Risk:** Deep directory trees cause stack overflow
3. **Potential Double-Free:** If `dir_ent->dir` is aliased (shared pointer)

**Attack Scenario:**

Create deeply nested directory structure:
```
/a/b/c/d/e/f/g/h/i/j/k/l/m/n/o/p/q/r/s/t/u/v/w/x/y/z/...
```

With 10,000 levels deep:
1. Each recursive call uses stack space
2. Typical stack size: 8MB
3. Each call frame: ~1KB (estimates vary)
4. 10,000 calls = ~10MB > 8MB stack
5. Stack overflow, crash

**Proof of Concept:**
```c
// Create 10,000 level deep directory
mkdir -p $(python -c 'print("/".join(["d"] * 10000))')

// Run squashfs on it
mksquashfs /path/to/deep output.sqfs

// When cleaning up, free_dir() recursively called 10,000 times
// Stack overflow
```

**Fix - Iterative Approach:**
```c
void free_dir(struct dir_info *dir)
{
    struct dir_stack {
        struct dir_info *dir;
        struct dir_ent *current;
        struct dir_stack *next;
    };
    
    struct dir_stack *stack = NULL;
    struct dir_stack *stack_item;
    
    // Push initial directory
    stack_item = MALLOC(sizeof(struct dir_stack));
    stack_item->dir = dir;
    stack_item->current = dir->list;
    stack_item->next = NULL;
    stack = stack_item;
    
    while(stack) {
        stack_item = stack;
        
        while(stack_item->current) {
            struct dir_ent *tmp = stack_item->current;
            
            if((tmp->inode->buf.st_mode & S_IFMT) == S_IFDIR && tmp->dir) {
                // Push subdirectory onto stack
                struct dir_stack *new_item = MALLOC(sizeof(struct dir_stack));
                new_item->dir = tmp->dir;
                new_item->current = tmp->dir->list;
                new_item->next = stack;
                stack = new_item;
                stack_item = new_item;
            }
            
            stack_item->current = tmp->next;
            if((tmp->inode->buf.st_mode & S_IFMT) != S_IFDIR || !tmp->dir)
                free_dir_entry(tmp);
        }
        
        // Free current directory
        free(stack_item->dir->pathname);
        free(stack_item->dir->subpath);
        free(stack_item->dir);
        
        // Pop from stack
        stack = stack_item->next;
        free(stack_item);
    }
}
```

**Fix - With Recursion Limit:**
```c
#define MAX_DIR_DEPTH 4096

void free_dir_recursive(struct dir_info *dir, int depth)
{
    if(depth > MAX_DIR_DEPTH)
        BAD_ERROR("Directory nesting too deep\n");
    
    struct dir_ent *dir_ent = dir->list;
    
    while(dir_ent) {
        struct dir_ent *tmp = dir_ent;
        
        if((dir_ent->inode->buf.st_mode & S_IFMT) == S_IFDIR)
            if(dir_ent->dir)
                free_dir_recursive(dir_ent->dir, depth + 1);
        
        dir_ent = dir_ent->next;
        free_dir_entry(tmp);
    }
    
    free(dir->pathname);
    free(dir->subpath);
    free(dir);
}

void free_dir(struct dir_info *dir)
{
    free_dir_recursive(dir, 0);
}
```

## 4. Race Conditions

### Analysis: Thread Safety Issues

#### Vulnerability 6: Shared state without mutex verification

**File:** `squashfs-tools/thread.c`  
**Lines:** 50-58  
**Function:** `set_thread_idle()`  
**Severity:** MEDIUM

**Vulnerable Code:**
```c
/*
 * Called with the thread mutex held.
 */
void set_thread_idle(int tid)
{
    if(threads[tid].type == THREAD_BLOCK)
        active_blocks --;
    else
        active_frags --;
    
    if(waiting_threads)
        pthread_cond_signal(&idle);
    
    threads[tid].state = THREAD_IDLE;
}
```

**Vulnerability Details:**

1. **No Enforcement:** Comment says "Called with the thread mutex held" but no verification
2. **Shared State:** Modifies `active_blocks`, `active_frags`, `threads[tid].state` without lock
3. **Race Condition:** If called without mutex, race conditions occur

**Attack Scenario:**

If function is called without holding mutex:
```c
// Thread 1
set_thread_idle(0);  // Forgot to lock mutex

// Thread 2 (simultaneously)
set_thread_idle(0);  // Forgot to lock mutex

// Both threads decrement active_blocks
// Expected: active_blocks -= 1
// Actual: active_blocks -= 1 (race condition, one decrement lost)
```

**Fix:**
```c
#ifdef DEBUG
#define ASSERT_MUTEX_HELD(mutex) \
    do { \
        int ret = pthread_mutex_trylock(mutex); \
        if(ret == 0) { \
            pthread_mutex_unlock(mutex); \
            BAD_ERROR("Mutex not held: %s\n", #mutex); \
        } \
    } while(0)
#else
#define ASSERT_MUTEX_HELD(mutex)
#endif

void set_thread_idle(int tid)
{
    ASSERT_MUTEX_HELD(&thread_mutex);
    
    if(threads[tid].type == THREAD_BLOCK)
        active_blocks --;
    else
        active_frags --;
    
    if(waiting_threads)
        pthread_cond_signal(&idle);
    
    threads[tid].state = THREAD_IDLE;
}
```

## Summary of Findings

| Vulnerability | File | Severity | Type | Exploitable |
|---------------|------|----------|------|-------------|
| Nested strcat() | mksquashfs.c | HIGH | Buffer Overflow | Yes (local) |
| Loop strcat() | unsquashfs.c | HIGH | Buffer Overflow | Yes (local) |
| Integer overflow in size calc | unsquashfs.c | HIGH | Integer Overflow â†’ Buffer Overflow | Yes (local) |
| Unchecked addition | mksquashfs.c | MEDIUM | Integer Overflow | Possibly |
| Shift overflow | mksquashfs.c | LOW-MEDIUM | Integer Overflow | Unlikely |
| Recursive free | mksquashfs.c | LOW-MEDIUM | Stack Overflow | Yes (DoS) |
| Race condition | thread.c | MEDIUM | Race Condition | Unlikely |

## Exploitation Difficulty

- **Local Attack Surface:** Most vulnerabilities require local file system access
- **Input Control:** Attacker needs to control file names, directory structure, or command line arguments
- **Constraints:** System limits (PATH_MAX, filesystem limits) may prevent some attacks
- **Mitigations:** Modern OS protections (ASLR, stack canaries, NX) make exploitation harder

## Recommendations

1. **Immediate:** Replace all `strcpy()`/`strcat()` with bounds-checked versions
2. **Short-term:** Add overflow checks to all size calculations
3. **Medium-term:** Implement fuzzing infrastructure
4. **Long-term:** Migrate to memory-safe language for critical components
